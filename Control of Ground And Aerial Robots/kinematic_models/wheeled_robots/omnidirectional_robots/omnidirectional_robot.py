from numpy import array, ndarray, sum as np_sum
from matplotlib.axes import Axes
from common.affine import rotational_affine
from common.angular_velocity import omega_from_v_r
from omni_wheel import OmniWheel


class OmnidirectionalRobot:
    def __init__(self, num_wheels, velocity_color='orange', wheel_color='black', motor_velocities=None):
        if num_wheels < 3:
            raise ValueError("Omnidirectional robot must have at least 3 wheels")
        self.num_wheels = num_wheels
        self.wheels: list[OmniWheel] = []
        self.velocity_color = velocity_color
        self.wheel_color = wheel_color
        self.position = array([0, 0])
        self.orientation = 0

        self.motor_velocities = array([0] * num_wheels) if motor_velocities is None else motor_velocities

        if len(self.motor_velocities) != num_wheels:
            raise ValueError("Motor velocities must be provided for each wheel")

    def move(self, x, y, orientation):
        self.position = array([x, y])
        self.orientation = orientation

    def add_wheel(self, wheel: OmniWheel):
        if len(self.wheels) < self.num_wheels:
            self.wheels.append(wheel)
        else:
            raise ValueError("All wheels have been added")

    def plot(self, ax: Axes, wheel_color=None):
        ax.set_aspect('equal')
        for wheel in self.wheels:
            wheel.plot(ax, robot_position=self.position, robot_orientation=self.orientation,
                       color=wheel_color or self.wheel_color)

    def plot_velocity(self, ax: Axes, wheel_color=None, velocity_color=None):
        ax.set_aspect('equal')
        for wheel, vel in zip(self.wheels, self.motor_velocities):
            wheel.velocity = vel
            wheel.plot(ax, robot_position=self.position, robot_orientation=self.orientation,
                       color=wheel_color or self.wheel_color)
            wheel.plot_velocity(ax,
                                robot_position=self.position, robot_orientation=self.orientation,
                                color=velocity_color or self.velocity_color)

    def get_angular_velocity(self):
        # 1. First calculate each wheel's velocity
        # 2. Calculate the angular velocity generated by the wheel velocities. You know that each wheel linear velocity
        # is the cross product of the wheel distance from the robot frame and the angular velocity of the robot.
        # since we already calculated the wheel velocities, we can use them to calculate the angular velocity.
        # 3. Calculate the robot angular velocity by summing each wheel's angular velocity.
        angular_velocities = [omega_from_v_r(wheel.get_velocity_components(motor_velocity),
                                             wheel.distance_from_robot_frame)
                              for wheel, motor_velocity
                              in zip(self.wheels, self.motor_velocities)]
        return sum(angular_velocities)

    def get_linear_velocity(self) -> ndarray:
        linear_velocity = np_sum([wheel.get_velocity_components(motor_velocity) for wheel, motor_velocity in
                                  zip(self.wheels, self.motor_velocities)], axis=0)
        return linear_velocity

    def global_state(self) -> ndarray:
        return array([*self.position, self.orientation, *self.global_velocity()])

    def global_velocity(self) -> ndarray:
        affine_matrix = rotational_affine('z', self.orientation)
        global_velocity = affine_matrix[:2, :2] @ self.get_linear_velocity()
        return array([*global_velocity, self.get_angular_velocity()])
