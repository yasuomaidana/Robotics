import numpy as np
from matplotlib import pyplot as plt
from numpy import array, ndarray, sum as np_sum
from matplotlib.axes import Axes
from common.affine import rotational_affine
from common.angular_velocity import omega_from_v_r
from omni_wheel import OmniWheel


class OmnidirectionalRobot:
    def __init__(self, num_wheels, velocity_color='orange', wheel_color='black', motor_velocities=None):
        if num_wheels < 3:
            raise ValueError("Omnidirectional robot must have at least 3 wheels")
        self.num_wheels = num_wheels
        self.wheels: list[OmniWheel] = []
        self.velocity_color = velocity_color
        self.wheel_color = wheel_color
        self.position = array([0, 0])
        self.orientation = 0

        self.motor_velocities = array([0] * num_wheels) if motor_velocities is None else motor_velocities

        if len(self.motor_velocities) != num_wheels:
            raise ValueError("Motor velocities must be provided for each wheel")

    def move(self, delta_T: float, motor_velocities: ndarray = None):
        if motor_velocities is not None:
            self.motor_velocities = motor_velocities
            # Update position
        global_vel = self.global_velocity()  # Get global velocities (linear and angular)
        self.position = self.position + global_vel[:2] * float(delta_T)

        # Update orientation
        self.orientation += global_vel[2] * delta_T
        self.orientation %= 2 * 360  # Ensure orientation stays within [0, 2Ï€)

    def add_wheel(self, wheel: OmniWheel):
        if len(self.wheels) < self.num_wheels:
            self.wheels.append(wheel)
        else:
            raise ValueError("All wheels have been added")

    def plot(self, ax: Axes, wheel_color=None):
        ax.set_aspect('equal')
        for wheel in self.wheels:
            wheel.plot(ax, robot_position=self.position, robot_orientation=self.orientation,
                       color=wheel_color or self.wheel_color)

    def plot_velocity(self, ax: Axes, wheel_color=None, velocity_color=None, global_velocity="green"):
        ax.set_aspect('equal')
        for wheel, vel in zip(self.wheels, self.motor_velocities):
            wheel.velocity = vel
            wheel.plot(ax, robot_position=self.position, robot_orientation=self.orientation,
                       color=wheel_color or self.wheel_color)
            wheel.plot_velocity(ax,
                                robot_position=self.position, robot_orientation=self.orientation,
                                color=velocity_color or self.velocity_color)
        ax.quiver(self.position[0], self.position[1], *self.global_velocity()[:2], color=global_velocity)

    def get_angular_velocity(self):
        # 1. First calculate each wheel's velocity
        # 2. Calculate the angular velocity generated by the wheel velocities. You know that each wheel linear velocity
        # is the cross product of the wheel distance from the robot frame and the angular velocity of the robot.
        # since we already calculated the wheel velocities, we can use them to calculate the angular velocity.
        # 3. Calculate the robot angular velocity by summing each wheel's angular velocity.
        angular_velocities = [omega_from_v_r(wheel.get_velocity_components(motor_velocity),
                                             wheel.distance_from_robot_frame)
                              for wheel, motor_velocity
                              in zip(self.wheels, self.motor_velocities)]
        return sum(angular_velocities)

    def get_linear_velocity(self) -> ndarray:
        linear_velocity = np_sum([wheel.get_velocity_components(motor_velocity) for wheel, motor_velocity in
                                  zip(self.wheels, self.motor_velocities)], axis=0)
        return linear_velocity

    def global_state(self) -> ndarray:
        return array([*self.position, self.orientation, *self.global_velocity()])

    def global_velocity(self) -> ndarray:
        affine_matrix = rotational_affine('z', self.orientation)
        global_velocity = affine_matrix[:2, :2] @ self.get_linear_velocity()
        return array([*global_velocity, self.get_angular_velocity()])

    def simulate_and_plot(self, motor_velocities, time_steps, ax=None):
        """
        Simulates robot movement and plots the trajectory and velocities.

        Args:
            motor_velocities: A list of motor velocity arrays or a single array.
            time_steps: A list of time steps or a float representing the total simulation time.
            ax: A matplotlib Axes object (optional). If not provided, a new one is created.
        """

        # Prepare motor velocities and time steps
        if isinstance(motor_velocities[0], (int, float)):  # Single array of motor velocities
            num_states = len(time_steps) if isinstance(time_steps, list) else round(time_steps / motor_velocities[0])
            motor_velocities = np.tile(motor_velocities, (num_states, 1))

        if not isinstance(time_steps, list):  # Single float representing total time
            time_steps = np.linspace(0, time_steps, len(motor_velocities))

        if ax is None:
            fig, ax = plt.subplots(figsize=(10, 8))

        # Simulate and plot
        positions = [self.position.copy()]
        global_velocities = [self.global_velocity().copy()]
        for i, (motor_vels, dt) in enumerate(zip(motor_velocities, time_steps)):
            self.motor_velocities = motor_vels  # Set motor velocities
            self.move(dt)  # Update robot state
            positions.append(self.position.copy())
            global_velocities.append(self.global_velocity().copy())
            self.plot_velocity(ax, velocity_color="none")  # Plot wheels and velocities at this time step
        positions = np.array(positions)
        global_velocities = np.array(global_velocities)

        # Plot trajectory, robot body and initial and final state
        ax.plot(positions[:, 0], positions[:, 1], 'b-', label='Robot Trajectory')
        self.plot(ax)

        # Plot velocities
        for i in range(len(global_velocities)):
            vel = global_velocities[i]
            ax.quiver(positions[i, 0], positions[i, 1], vel[0], vel[1], scale=1 if vel[0] == vel[1] == 0 else None,
                      color="orange")

        ax.set_xlabel('X (meters)')
        ax.set_ylabel('Y (meters)')
        ax.set_title('Robot Trajectory and Velocities')
        ax.legend()
        ax.grid(True)

        return ax
